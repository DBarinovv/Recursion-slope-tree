# Мой язык программирования
>Перед написанием самого языка нам понадобится собственный асемблер (на котором он и будет исполняться).  
>[Мой асемблер](https://github.com/DBarinovv/cpu)
---
**Для написания языка нам потребуется**:
* [*рекурсивный спуск*](https://github.com/DBarinovv/Recursion-slope-tree/new/master?readme=1#немного-о-рекурсивном-спуске)
* [*свой синтаксис*](https://github.com/DBarinovv/Recursion-slope-tree/new/master?readme=1#синтаксис)
* [*сгенерировать по дереву ассемблерный код*](https://github.com/DBarinovv/Recursion-slope-tree/new/master?readme=1#генерация-кода-по-дереву)

---

### Немного о рекурсивном спуске

У нас есть функции вида:
```C
node_t* Get_G ();
node_t* Get_E ();
.
.
.
node_t* Get_N();
```
  Каждая из них запускает следующую, после чего выполняется код, зависящий от строки, которую мы парсим.
(Зачастую это просто return, так как ничего делать не надо)
То есть каждая функция вида Get_ отвечает за какую-то операцию. Рассмотрим на примере Get_E ():
```C
node_t* Get_E ()
{
    node_t* node1 = Get_T ();
    node_t* new_res = nullptr;

    while (*G_code == '+' || *G_code == '-')
    {
        char op = *G_code;

        G_code++;

        node_t* node2 = Get_T ();

        if (op == '+') new_res = Create_Node (E_plus,  E_op);
        else           new_res = Create_Node (E_minus, E_op);

        new_res->left  = node1;
        new_res->right = node2;

        node1 = new_res;
    }

    return node1;
}
```
На данном примере мы видим, что вначале мы вызвали функцию Get_T, которая вернула указатель на вершину.
Дальше происходит следующее:
- Если тот элемент строки, на который сейчас указывает G_code равен '+' или '-', 
то мы создаём вершину с '+' или '-' соотвественно, оба ребёнка которой - выражения, которые мы складываем/вычитаем.
Так делаем, пока символ не '+' или '-' (каждый раз создавая новую вершину и подвешивая на неё нужные вершины (выражения)).
После чего возвращаем последнюю созданную.
- Иначе мы ничего не делаем и просто возвращаем указатель на вершину, который вернула функция Get_T

#### [Назад](https://github.com/DBarinovv/Recursion-slope-tree/new/master?readme=1#мой-язык-программирования)
---
### Синтаксис
Чтобы не писать простой С, а привнести что-то своё, сделаем следующую замену названий:
| in C/asm | my language | на русской расскладке |
|--------|----------|---------|
| if     | ba       | иф      |
| while  | dfqk     | вайл    |
| func   | aeyrwbz  | функция |
| return | htnthy   | ретерн  |
| start  | cnfhn    | старт   |
| print  | ghbyn    | принт   |
| end    | rjytw    | конец   |

Пример кода на С:
```C
if (c == 0)
{
    printf ("Hello_world");
    return;  
}
```
Эквивалентный код на моём языке:
```
ba(c==0)
ghbyn_Hello_world!
rjytw
;
```
Отступы, как и пробелы ставить необязательно, но можно, и if заканчивается ';'. Строки заканчиваются '!'.

#### [Назад](https://github.com/DBarinovv/Recursion-slope-tree/new/master?readme=1#мой-язык-программирования)

---
### Генерация кода по дереву
Часть построенного нами дерева:
![Часть построенного нами дерева](https://github.com/DBarinovv/Recursion-slope-tree/blob/master/Example_tree.png)
Поясню, что означают вершины:
* (Line = [0]) - просто связующую вершина, ни за что не отвечающая
* (_no_roots!) - printf ("no_roots")
* (END)        - return
* (if)         - если верно левое поддерево, то выполянем правое
* (<=)         - верно, если выражение в левом поддереве <= выражения в правом

Тогда, всё что нужно для генерации кода - запустить DFS и последовательно выводить ассемблерные команды
#### [Назад](https://github.com/DBarinovv/Recursion-slope-tree/new/master?readme=1#мой-язык-программирования)
>***Таким образом, мы написали свой язык программирования и протестировали его на квадратном уравнении и вычислении факториала числа***
#### [Назад](https://github.com/DBarinovv/Recursion-slope-tree/new/master?readme=1#мой-язык-программирования)
